<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Film and Photography</title>

    <!-- Original links preserved -->
    <link rel="stylesheet" href="dog2019.css">
    <link type="text/css" rel="stylesheet" href="utopia.css"/>
    <link rel="stylesheet" href="readable/readable.css">
    <link rel="shortcut icon" href="cc4.ico" type="image/x-icon" />

    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: #000;
            line-height: 1.6;
            font-size: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        div#bottomdiv {
            position: fixed;
            bottom: 0px;
            left: 0px;
            width: 100%;
            color: #FFFFFF;
            background: #f9f9f9;
            padding: 8px;
        }

        #model-viewer {
            width: calc(90% - 40px); /* Adjusting for 20px margin and padding */
            height: calc(300px - 40px); /* Adjusting for 20px margin and padding */
            margin: 20px;
            padding: 20px;
            background-color: #ffffff;
            border: 1px solid #ddd;
            position: relative;
        }

        a:link {
            color: #000;
            font-weight: bold;
            text-decoration: none;
        }

        a:visited {
            text-decoration: none;
            color: #E6E6E6;
        }

        a:hover {
            text-decoration: none;
            color: #F00;
        }

        a:active {
            text-decoration: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            #model-viewer {
                height: calc(200px - 40px);
            }

            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="model-viewer"></div>

        <br />
        <p>Production Companies</p>
        <br />
        <p>Young and Grumpy - @youngandgrumpy<br>
        Young and Grumpy Productions is a Brooklyn-based company specializing in photo and video production, particularly for product and tabletop content. Known for its versatility, the company provides high-quality services for clients across Brooklyn, Queens, and Manhattan. They cater to both low-budget and high-end productions, ensuring flexibility and affordability without compromising on quality.
        <a href="https://www.theyoungandgrumpy.com"><u>www.theyoungandgrumpy.com</u></a></p>

        <br>
        <h2>Photographers, Videographers, Film Sound:</h2>
        <p>Troy Vetri - Troy Vetri is a talented Director of Photography known for his work in documentaries and commercials. His notable projects include "The Total Solar Eclipse as a Catalyst for Art in Erie," "Hot Ones | Truth or Dab with Gigi Hadid and Tan France," and "Science in Service of Community". Vetri's work often explores themes of community, science, and art, showcasing his ability to capture impactful and visually stunning stories.
        <a href="/www.troyvetri.com/"><u>/www.troyvetri.com/</u></a></p>

        <p>Tara Sgroi
        <a href="www.tarasgroi.com"><u>www.tarasgroi.com</u></a></p>

        <p>Jordan Studdard @jordanstuddard - 
        Jordan Studdard, known on TikTok as @jordanstuddard, is a content creator celebrated for his whimsical and imaginative short-form videos. He often features various characters he refers to as his "friends," such as Jacob, Natalia, and Catherine. With over 20.2 million likes and 776,000 followers, Studdard has built a significant following by crafting engaging and creative stories. Based in New York City, he shares his creative journey, including building miniature studios and DIY projects. His content is a blend of storytelling, creativity, and personal experiences, making him a beloved figure on social media.</p>

        <p>Yago @yagowashere</p>

        <p>Adam Aslan - @nycpony<br>
        Adam Timur Aslan incorporates full-stack development with interests in film sound, 3d Animation, music, writing, and brutalist design to produce music videos and other web content.</p>
    </div>

    <div id="bottomdiv">
        <!-- Original bottom content -->
    </div>
<!-- HTML -->
<div id="model-viewer" style="width: 100%; height: 100%;"></div>



 <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const modelViewer = document.getElementById('model-viewer');
        modelViewer.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        const loader = new THREE.GLTFLoader();
        let model;
        let targetPosition = new THREE.Vector3();
        let speed = 0.02;

        function getUsableCanvasBounds() {
            const width = modelViewer.clientWidth;
            const height = modelViewer.clientHeight;

            // Define borders (10% of canvas width/height)
            const borderX = width * 0.1;
            const borderY = height * 0.1;

            return {
                minX: borderX,
                maxX: width - borderX,
                minY: borderY,
                maxY: height - borderY,
                width: width - 2 * borderX,
                height: height - 2 * borderY,
            };
        }

        loader.load('cebollito2.glb', function (gltf) {
            model = gltf.scene;

            // Calculate the bounding box of the model
            const bbox = new THREE.Box3().setFromObject(model);
            const modelSize = {
                width: bbox.max.x - bbox.min.x,
                height: bbox.max.y - bbox.min.y,
                depth: bbox.max.z - bbox.min.z,
            };

            // Get usable canvas bounds
            const bounds = getUsableCanvasBounds();

            // Scale the model to fit within the usable bounds
            const scaleX = bounds.width / modelSize.width;
            const scaleY = bounds.height / modelSize.height;
            const scale = Math.min(scaleX, scaleY) * 0.9; // Scale down slightly to leave some padding
            model.scale.set(scale, scale, scale);

            // Center the model in the scene
            model.position.set(0, -modelSize.height / 2 * scale, 0);

            scene.add(model);

            // Adjust camera position
            camera.position.z = modelSize.depth * scale * 2;
            updateRendererSize();
        }, undefined, function (error) {
            console.error(error);
        });

        function animate() {
            requestAnimationFrame(animate);

            if (model) {
                // Chaotic movement
                const bounds = getUsableCanvasBounds();
                if (model.position.distanceTo(targetPosition) < 0.1) {
                    targetPosition.set(
                        THREE.MathUtils.randFloat(bounds.minX, bounds.maxX),
                        THREE.MathUtils.randFloat(bounds.minY, bounds.maxY),
                        THREE.MathUtils.randFloat(-bounds.height / 2, bounds.height / 2)
                    );
                }

                model.position.lerp(targetPosition, speed);

                // Rotation
                model.rotation.y += 0.02;
            }

            renderer.render(scene, camera);
        }

        function updateRendererSize() {
            const width = modelViewer.clientWidth;
            const height = modelViewer.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            // Recalculate bounds and adjust model
            if (model) {
                const bounds = getUsableCanvasBounds();
                const bbox = new THREE.Box3().setFromObject(model);
                const modelSize = {
                    width: bbox.max.x - bbox.min.x,
                    height: bbox.max.y - bbox.min.y,
                };

                const scaleX = bounds.width / modelSize.width;
                const scaleY = bounds.height / modelSize.height;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                model.scale.set(scale, scale, scale);
                model.position.set(0, -modelSize.height / 2 * scale, 0);
            }
        }

        window.addEventListener('resize', updateRendererSize);
        animate();
    </script>
</body>
</html>
